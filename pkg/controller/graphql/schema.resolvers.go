package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"encoding/json"

	goerr "github.com/m-mizutani/goerr/v2"
	"github.com/secmon-lab/hecatoncheires/pkg/domain/model"
	graphql1 "github.com/secmon-lab/hecatoncheires/pkg/domain/model/graphql"
	"github.com/secmon-lab/hecatoncheires/pkg/domain/types"
)

// Case is the resolver for the case field.
func (r *actionResolver) Case(ctx context.Context, obj *graphql1.Action) (*graphql1.Case, error) {
	loaders := GetDataLoaders(ctx)
	cases, err := loaders.CaseLoader.Load(ctx, obj.WorkspaceID, []int64{int64(obj.CaseID)})
	if err != nil {
		return nil, err
	}
	if len(cases) == 0 {
		return nil, nil
	}
	return toGraphQLCase(cases[0], obj.WorkspaceID), nil
}

// Assignees is the resolver for the assignees field.
func (r *actionResolver) Assignees(ctx context.Context, obj *graphql1.Action) ([]*graphql1.SlackUser, error) {
	if len(obj.AssigneeIDs) == 0 {
		return []*graphql1.SlackUser{}, nil
	}
	loaders := GetDataLoaders(ctx)
	return loaders.SlackUserLoader.Load(ctx, obj.AssigneeIDs)
}

// Assignees is the resolver for the assignees field.
func (r *caseResolver) Assignees(ctx context.Context, obj *graphql1.Case) ([]*graphql1.SlackUser, error) {
	if len(obj.AssigneeIDs) == 0 {
		return []*graphql1.SlackUser{}, nil
	}
	loaders := GetDataLoaders(ctx)
	return loaders.SlackUserLoader.Load(ctx, obj.AssigneeIDs)
}

// SlackChannelName is the resolver for the slackChannelName field.
func (r *caseResolver) SlackChannelName(ctx context.Context, obj *graphql1.Case) (*string, error) {
	if obj.SlackChannelID == nil || *obj.SlackChannelID == "" {
		return nil, nil
	}
	slackSvc := r.UseCases.SlackService()
	if slackSvc == nil {
		return nil, nil
	}
	names, err := slackSvc.GetChannelNames(ctx, []string{*obj.SlackChannelID})
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get Slack channel name",
			goerr.V("channel_id", *obj.SlackChannelID))
	}
	if name, ok := names[*obj.SlackChannelID]; ok {
		return &name, nil
	}
	return nil, nil
}

// SlackChannelURL is the resolver for the slackChannelURL field.
func (r *caseResolver) SlackChannelURL(ctx context.Context, obj *graphql1.Case) (*string, error) {
	if obj.SlackChannelID == nil || *obj.SlackChannelID == "" {
		return nil, nil
	}
	slackSvc := r.UseCases.SlackService()
	if slackSvc == nil {
		return nil, nil
	}
	teamURL, err := slackSvc.GetTeamURL(ctx)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to get Slack team URL")
	}
	url := teamURL + "/archives/" + *obj.SlackChannelID
	return &url, nil
}

// Fields is the resolver for the fields field.
func (r *caseResolver) Fields(ctx context.Context, obj *graphql1.Case) ([]*graphql1.FieldValue, error) {
	// Field values are embedded in the Case and pre-populated by toGraphQLCase
	if obj.Fields == nil {
		return []*graphql1.FieldValue{}, nil
	}
	return obj.Fields, nil
}

// Actions is the resolver for the actions field.
func (r *caseResolver) Actions(ctx context.Context, obj *graphql1.Case) ([]*graphql1.Action, error) {
	loaders := GetDataLoaders(ctx)
	actionsMap, err := loaders.ActionsByCaseLoader.Load(ctx, obj.WorkspaceID, []int64{int64(obj.ID)})
	if err != nil {
		return nil, err
	}
	actions, ok := actionsMap[int64(obj.ID)]
	if !ok {
		return []*graphql1.Action{}, nil
	}

	// Convert domain Actions to GraphQL Actions
	result := make([]*graphql1.Action, len(actions))
	for i, a := range actions {
		result[i] = toGraphQLAction(a, obj.WorkspaceID)
	}
	return result, nil
}

// Knowledges is the resolver for the knowledges field.
func (r *caseResolver) Knowledges(ctx context.Context, obj *graphql1.Case) ([]*graphql1.Knowledge, error) {
	loaders := GetDataLoaders(ctx)
	knowledgesMap, err := loaders.KnowledgesByCaseLoader.Load(ctx, obj.WorkspaceID, []int64{int64(obj.ID)})
	if err != nil {
		return nil, err
	}
	knowledges, ok := knowledgesMap[int64(obj.ID)]
	if !ok {
		return []*graphql1.Knowledge{}, nil
	}

	// Convert domain Knowledge to GraphQL Knowledge
	result := make([]*graphql1.Knowledge, len(knowledges))
	for i, k := range knowledges {
		result[i] = toGraphQLKnowledge(k, obj.WorkspaceID)
	}
	return result, nil
}

// SlackMessages is the resolver for the slackMessages field.
func (r *caseResolver) SlackMessages(ctx context.Context, obj *graphql1.Case, limit *int, cursor *string) (*graphql1.SlackMessageConnection, error) {
	limitVal := 20
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}
	cursorVal := ""
	if cursor != nil {
		cursorVal = *cursor
	}

	messages, nextCursor, err := r.repo.CaseMessage().List(ctx, obj.WorkspaceID, int64(obj.ID), limitVal, cursorVal)
	if err != nil {
		return nil, goerr.Wrap(err, "failed to list case messages from repository")
	}

	items := make([]*graphql1.SlackMessage, len(messages))
	for i, m := range messages {
		threadTS := m.ThreadTS()
		var threadTSPtr *string
		if threadTS != "" {
			threadTSPtr = &threadTS
		}
		files := make([]*graphql1.SlackFile, len(m.Files()))
		for j, f := range m.Files() {
			thumbURL := f.ThumbURL()
			var thumbURLPtr *string
			if thumbURL != "" {
				thumbURLPtr = &thumbURL
			}
			files[j] = &graphql1.SlackFile{
				ID:         f.ID(),
				Name:       f.Name(),
				Mimetype:   f.Mimetype(),
				Filetype:   f.Filetype(),
				Size:       f.Size(),
				URLPrivate: f.URLPrivate(),
				Permalink:  f.Permalink(),
				ThumbURL:   thumbURLPtr,
			}
		}
		items[i] = &graphql1.SlackMessage{
			ID:        m.ID(),
			ChannelID: m.ChannelID(),
			ThreadTs:  threadTSPtr,
			TeamID:    m.TeamID(),
			UserID:    m.UserID(),
			UserName:  m.UserName(),
			Text:      m.Text(),
			Files:     files,
			CreatedAt: m.CreatedAt(),
		}
	}

	return &graphql1.SlackMessageConnection{
		Items:      items,
		NextCursor: nextCursor,
	}, nil
}

// Case is the resolver for the case field.
func (r *knowledgeResolver) Case(ctx context.Context, obj *graphql1.Knowledge) (*graphql1.Case, error) {
	loaders := GetDataLoaders(ctx)
	cases, err := loaders.CaseLoader.Load(ctx, obj.WorkspaceID, []int64{int64(obj.CaseID)})
	if err != nil {
		return nil, err
	}
	if len(cases) == 0 {
		return nil, nil
	}
	return toGraphQLCase(cases[0], obj.WorkspaceID), nil
}

// Noop is the resolver for the noop field.
func (r *mutationResolver) Noop(ctx context.Context) (*bool, error) {
	result := true
	return &result, nil
}

// CreateCase is the resolver for the createCase field.
func (r *mutationResolver) CreateCase(ctx context.Context, workspaceID string, input graphql1.CreateCaseInput) (*graphql1.Case, error) {
	assigneeIDs := input.AssigneeIDs
	if assigneeIDs == nil {
		assigneeIDs = []string{}
	}

	fieldValues := toDomainFieldValues(input.Fields)

	description := ""
	if input.Description != nil {
		description = *input.Description
	}

	created, err := r.UseCases.Case.CreateCase(ctx, workspaceID, input.Title, description, assigneeIDs, fieldValues)
	if err != nil {
		return nil, err
	}

	return toGraphQLCase(created, workspaceID), nil
}

// UpdateCase is the resolver for the updateCase field.
func (r *mutationResolver) UpdateCase(ctx context.Context, workspaceID string, input graphql1.UpdateCaseInput) (*graphql1.Case, error) {
	assigneeIDs := input.AssigneeIDs
	if assigneeIDs == nil {
		assigneeIDs = []string{}
	}

	fieldValues := toDomainFieldValues(input.Fields)

	description := ""
	if input.Description != nil {
		description = *input.Description
	}

	updated, err := r.UseCases.Case.UpdateCase(ctx, workspaceID, int64(input.ID), input.Title, description, assigneeIDs, fieldValues)
	if err != nil {
		return nil, err
	}

	return toGraphQLCase(updated, workspaceID), nil
}

// DeleteCase is the resolver for the deleteCase field.
func (r *mutationResolver) DeleteCase(ctx context.Context, workspaceID string, id int) (bool, error) {
	if err := r.UseCases.Case.DeleteCase(ctx, workspaceID, int64(id)); err != nil {
		return false, err
	}
	return true, nil
}

// CloseCase is the resolver for the closeCase field.
func (r *mutationResolver) CloseCase(ctx context.Context, workspaceID string, id int) (*graphql1.Case, error) {
	closed, err := r.UseCases.Case.CloseCase(ctx, workspaceID, int64(id))
	if err != nil {
		return nil, err
	}
	return toGraphQLCase(closed, workspaceID), nil
}

// ReopenCase is the resolver for the reopenCase field.
func (r *mutationResolver) ReopenCase(ctx context.Context, workspaceID string, id int) (*graphql1.Case, error) {
	reopened, err := r.UseCases.Case.ReopenCase(ctx, workspaceID, int64(id))
	if err != nil {
		return nil, err
	}
	return toGraphQLCase(reopened, workspaceID), nil
}

// CreateAction is the resolver for the createAction field.
func (r *mutationResolver) CreateAction(ctx context.Context, workspaceID string, input graphql1.CreateActionInput) (*graphql1.Action, error) {
	assigneeIDs := input.AssigneeIDs
	if assigneeIDs == nil {
		assigneeIDs = []string{}
	}

	slackMessageTS := ""
	if input.SlackMessageTs != nil {
		slackMessageTS = *input.SlackMessageTs
	}

	status := types.ActionStatusTodo
	if input.Status != nil {
		status = *input.Status
	}

	description := ""
	if input.Description != nil {
		description = *input.Description
	}

	created, err := r.UseCases.Action.CreateAction(ctx, workspaceID, int64(input.CaseID), input.Title, description, assigneeIDs, slackMessageTS, status)
	if err != nil {
		return nil, err
	}

	return toGraphQLAction(created, workspaceID), nil
}

// UpdateAction is the resolver for the updateAction field.
func (r *mutationResolver) UpdateAction(ctx context.Context, workspaceID string, input graphql1.UpdateActionInput) (*graphql1.Action, error) {
	var caseID *int64
	if input.CaseID != nil {
		id := int64(*input.CaseID)
		caseID = &id
	}

	var slackMessageTS *string
	if input.SlackMessageTs != nil {
		slackMessageTS = input.SlackMessageTs
	}

	var status *types.ActionStatus
	if input.Status != nil {
		status = input.Status
	}

	updated, err := r.UseCases.Action.UpdateAction(ctx, workspaceID, int64(input.ID), caseID, input.Title, input.Description, input.AssigneeIDs, slackMessageTS, status)
	if err != nil {
		return nil, err
	}

	return toGraphQLAction(updated, workspaceID), nil
}

// DeleteAction is the resolver for the deleteAction field.
func (r *mutationResolver) DeleteAction(ctx context.Context, workspaceID string, id int) (bool, error) {
	if err := r.UseCases.Action.DeleteAction(ctx, workspaceID, int64(id)); err != nil {
		return false, err
	}
	return true, nil
}

// CreateNotionDBSource is the resolver for the createNotionDBSource field.
func (r *mutationResolver) CreateNotionDBSource(ctx context.Context, workspaceID string, input graphql1.CreateNotionDBSourceInput) (*graphql1.Source, error) {
	created, err := r.UseCases.Source.CreateNotionDBSource(ctx, workspaceID, toUseCaseCreateNotionDBSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(created)
}

// CreateNotionPageSource is the resolver for the createNotionPageSource field.
func (r *mutationResolver) CreateNotionPageSource(ctx context.Context, workspaceID string, input graphql1.CreateNotionPageSourceInput) (*graphql1.Source, error) {
	created, err := r.UseCases.Source.CreateNotionPageSource(ctx, workspaceID, toUseCaseCreateNotionPageSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(created)
}

// CreateSlackSource is the resolver for the createSlackSource field.
func (r *mutationResolver) CreateSlackSource(ctx context.Context, workspaceID string, input graphql1.CreateSlackSourceInput) (*graphql1.Source, error) {
	created, err := r.UseCases.Source.CreateSlackSource(ctx, workspaceID, toUseCaseCreateSlackSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(created)
}

// UpdateSource is the resolver for the updateSource field.
func (r *mutationResolver) UpdateSource(ctx context.Context, workspaceID string, input graphql1.UpdateSourceInput) (*graphql1.Source, error) {
	updated, err := r.UseCases.Source.UpdateSource(ctx, workspaceID, toUseCaseUpdateSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(updated)
}

// UpdateSlackSource is the resolver for the updateSlackSource field.
func (r *mutationResolver) UpdateSlackSource(ctx context.Context, workspaceID string, input graphql1.UpdateSlackSourceInput) (*graphql1.Source, error) {
	updated, err := r.UseCases.Source.UpdateSlackSource(ctx, workspaceID, toUseCaseUpdateSlackSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(updated)
}

// DeleteSource is the resolver for the deleteSource field.
func (r *mutationResolver) DeleteSource(ctx context.Context, workspaceID string, id string) (bool, error) {
	if err := r.UseCases.Source.DeleteSource(ctx, workspaceID, model.SourceID(id)); err != nil {
		return false, err
	}
	return true, nil
}

// ValidateNotionDb is the resolver for the validateNotionDB field.
func (r *mutationResolver) ValidateNotionDb(ctx context.Context, workspaceID string, databaseID string) (*graphql1.NotionDBValidationResult, error) {
	result, err := r.UseCases.Source.ValidateNotionDB(ctx, databaseID)
	if err != nil {
		return nil, err
	}

	gql := &graphql1.NotionDBValidationResult{
		Valid: result.Valid,
	}
	if result.DatabaseTitle != "" {
		gql.DatabaseTitle = &result.DatabaseTitle
	}
	if result.DatabaseURL != "" {
		gql.DatabaseURL = &result.DatabaseURL
	}
	if result.ErrorMessage != "" {
		gql.ErrorMessage = &result.ErrorMessage
	}

	return gql, nil
}

// ValidateNotionPage is the resolver for the validateNotionPage field.
func (r *mutationResolver) ValidateNotionPage(ctx context.Context, workspaceID string, pageID string) (*graphql1.NotionPageValidationResult, error) {
	result, err := r.UseCases.Source.ValidateNotionPage(ctx, pageID)
	if err != nil {
		return nil, err
	}

	gql := &graphql1.NotionPageValidationResult{
		Valid: result.Valid,
	}
	if result.PageTitle != "" {
		gql.PageTitle = &result.PageTitle
	}
	if result.PageURL != "" {
		gql.PageURL = &result.PageURL
	}
	if result.ErrorMessage != "" {
		gql.ErrorMessage = &result.ErrorMessage
	}

	return gql, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "ok", nil
}

// Workspace is the resolver for the workspace field.
func (r *queryResolver) Workspace(ctx context.Context, workspaceID string) (*graphql1.Workspace, error) {
	entry, err := r.UseCases.WorkspaceRegistry().Get(workspaceID)
	if err != nil {
		return nil, err
	}
	return &graphql1.Workspace{
		ID:   entry.Workspace.ID,
		Name: entry.Workspace.Name,
	}, nil
}

// Workspaces is the resolver for the workspaces field.
func (r *queryResolver) Workspaces(ctx context.Context) ([]*graphql1.Workspace, error) {
	entries := r.UseCases.WorkspaceRegistry().List()
	result := make([]*graphql1.Workspace, len(entries))
	for i, entry := range entries {
		result[i] = &graphql1.Workspace{
			ID:   entry.Workspace.ID,
			Name: entry.Workspace.Name,
		}
	}
	return result, nil
}

// Cases is the resolver for the cases field.
func (r *queryResolver) Cases(ctx context.Context, workspaceID string, status *types.CaseStatus) ([]*graphql1.Case, error) {
	cases, err := r.UseCases.Case.ListCases(ctx, workspaceID, status)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Case, len(cases))
	for i, c := range cases {
		result[i] = toGraphQLCase(c, workspaceID)
	}

	return result, nil
}

// Case is the resolver for the case field.
func (r *queryResolver) Case(ctx context.Context, workspaceID string, id int) (*graphql1.Case, error) {
	c, err := r.UseCases.Case.GetCase(ctx, workspaceID, int64(id))
	if err != nil {
		return nil, err
	}

	return toGraphQLCase(c, workspaceID), nil
}

// Actions is the resolver for the actions field.
func (r *queryResolver) Actions(ctx context.Context, workspaceID string) ([]*graphql1.Action, error) {
	actions, err := r.UseCases.Action.ListActions(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Action, len(actions))
	for i, a := range actions {
		result[i] = toGraphQLAction(a, workspaceID)
	}

	return result, nil
}

// Action is the resolver for the action field.
func (r *queryResolver) Action(ctx context.Context, workspaceID string, id int) (*graphql1.Action, error) {
	a, err := r.UseCases.Action.GetAction(ctx, workspaceID, int64(id))
	if err != nil {
		return nil, err
	}

	return toGraphQLAction(a, workspaceID), nil
}

// ActionsByCase is the resolver for the actionsByCase field.
func (r *queryResolver) ActionsByCase(ctx context.Context, workspaceID string, caseID int) ([]*graphql1.Action, error) {
	actions, err := r.UseCases.Action.GetActionsByCase(ctx, workspaceID, int64(caseID))
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Action, len(actions))
	for i, a := range actions {
		result[i] = toGraphQLAction(a, workspaceID)
	}

	return result, nil
}

// OpenCaseActions is the resolver for the openCaseActions field.
func (r *queryResolver) OpenCaseActions(ctx context.Context, workspaceID string) ([]*graphql1.Action, error) {
	actions, err := r.UseCases.Action.ListOpenCaseActions(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Action, len(actions))
	for i, a := range actions {
		result[i] = toGraphQLAction(a, workspaceID)
	}

	return result, nil
}

// FieldConfiguration is the resolver for the fieldConfiguration field.
func (r *queryResolver) FieldConfiguration(ctx context.Context, workspaceID string) (*graphql1.FieldConfiguration, error) {
	schema := r.UseCases.Case.GetFieldConfiguration(workspaceID)

	fields := make([]*graphql1.FieldDefinition, len(schema.Fields))
	for i, field := range schema.Fields {
		options := make([]*graphql1.FieldOption, len(field.Options))
		for j, opt := range field.Options {
			color := ""
			if opt.Color != "" {
				color = opt.Color
			}
			metadata := opt.Metadata
			if metadata == nil {
				metadata = make(map[string]any)
			}
			metadataJSON, _ := json.Marshal(metadata)
			metadataStr := string(metadataJSON)

			options[j] = &graphql1.FieldOption{
				ID:          opt.ID,
				Name:        opt.Name,
				Description: &opt.Description,
				Color:       &color,
				Metadata:    &metadataStr,
			}
		}

		fieldType := toGraphQLFieldType(field.Type)

		fields[i] = &graphql1.FieldDefinition{
			ID:          field.ID,
			Name:        field.Name,
			Type:        fieldType,
			Required:    field.Required,
			Description: &field.Description,
			Options:     options,
		}
	}

	return &graphql1.FieldConfiguration{
		Fields: fields,
		Labels: &graphql1.EntityLabels{
			Case: schema.Labels.Case,
		},
	}, nil
}

// SlackUsers is the resolver for the slackUsers field.
func (r *queryResolver) SlackUsers(ctx context.Context) ([]*graphql1.SlackUser, error) {
	users, err := r.repo.SlackUser().GetAll(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.SlackUser, len(users))
	for i, u := range users {
		var imageURL *string
		if u.ImageURL != "" {
			url := u.ImageURL
			imageURL = &url
		}
		result[i] = &graphql1.SlackUser{
			ID:       string(u.ID),
			Name:     u.Name,
			RealName: u.RealName,
			ImageURL: imageURL,
		}
	}

	return result, nil
}

// SlackJoinedChannels is the resolver for the slackJoinedChannels field.
func (r *queryResolver) SlackJoinedChannels(ctx context.Context) ([]*graphql1.SlackChannelInfo, error) {
	channels, err := r.UseCases.Source.ListSlackChannels(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.SlackChannelInfo, len(channels))
	for i, ch := range channels {
		result[i] = &graphql1.SlackChannelInfo{
			ID:   ch.ID,
			Name: ch.Name,
		}
	}

	return result, nil
}

// Sources is the resolver for the sources field.
func (r *queryResolver) Sources(ctx context.Context, workspaceID string) ([]*graphql1.Source, error) {
	sources, err := r.UseCases.Source.ListSources(ctx, workspaceID)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Source, 0, len(sources))
	for _, s := range sources {
		gql, err := toGraphQLSource(s)
		if err != nil {
			return nil, err
		}
		result = append(result, gql)
	}

	return result, nil
}

// Source is the resolver for the source field.
func (r *queryResolver) Source(ctx context.Context, workspaceID string, id string) (*graphql1.Source, error) {
	source, err := r.UseCases.Source.GetSource(ctx, workspaceID, model.SourceID(id))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(source)
}

// Knowledge is the resolver for the knowledge field.
func (r *queryResolver) Knowledge(ctx context.Context, workspaceID string, id string) (*graphql1.Knowledge, error) {
	knowledge, err := r.repo.Knowledge().Get(ctx, workspaceID, model.KnowledgeID(id))
	if err != nil {
		return nil, err
	}

	return toGraphQLKnowledge(knowledge, workspaceID), nil
}

// Knowledges is the resolver for the knowledges field.
func (r *queryResolver) Knowledges(ctx context.Context, workspaceID string, limit *int, offset *int) (*graphql1.KnowledgeConnection, error) {
	// Set defaults if not provided
	limitVal := 100
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}

	offsetVal := 0
	if offset != nil && *offset > 0 {
		offsetVal = *offset
	}

	knowledges, totalCount, err := r.repo.Knowledge().ListWithPagination(ctx, workspaceID, limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	// Convert domain Knowledge to GraphQL Knowledge
	items := make([]*graphql1.Knowledge, len(knowledges))
	for i, k := range knowledges {
		items[i] = toGraphQLKnowledge(k, workspaceID)
	}

	hasMore := (offsetVal + len(knowledges)) < totalCount

	return &graphql1.KnowledgeConnection{
		Items:      items,
		TotalCount: totalCount,
		HasMore:    hasMore,
	}, nil
}

// Action returns ActionResolver implementation.
func (r *Resolver) Action() ActionResolver { return &actionResolver{r} }

// Case returns CaseResolver implementation.
func (r *Resolver) Case() CaseResolver { return &caseResolver{r} }

// Knowledge returns KnowledgeResolver implementation.
func (r *Resolver) Knowledge() KnowledgeResolver { return &knowledgeResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type actionResolver struct{ *Resolver }
type caseResolver struct{ *Resolver }
type knowledgeResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
