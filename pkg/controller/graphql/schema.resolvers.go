package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/secmon-lab/hecatoncheires/pkg/domain/model"
	graphql1 "github.com/secmon-lab/hecatoncheires/pkg/domain/model/graphql"
	"github.com/secmon-lab/hecatoncheires/pkg/domain/types"
	"github.com/secmon-lab/hecatoncheires/pkg/utils/errutil"
)

// Noop is the resolver for the noop field.
func (r *mutationResolver) Noop(ctx context.Context) (*bool, error) {
	// TODO: Remove this dummy implementation when real mutations are added
	result := true
	return &result, nil
}

// CreateRisk is the resolver for the createRisk field.
func (r *mutationResolver) CreateRisk(ctx context.Context, input graphql1.CreateRiskInput) (*graphql1.Risk, error) {
	categoryIDs := make([]types.CategoryID, len(input.CategoryIDs))
	for i, id := range input.CategoryIDs {
		categoryIDs[i] = types.CategoryID(id)
	}

	teamIDs := make([]types.TeamID, len(input.ResponseTeamIDs))
	for i, id := range input.ResponseTeamIDs {
		teamIDs[i] = types.TeamID(id)
	}

	risk, err := r.uc.Risk.CreateRisk(
		ctx,
		input.Name,
		input.Description,
		categoryIDs,
		input.SpecificImpact,
		types.LikelihoodID(input.LikelihoodID),
		types.ImpactID(input.ImpactID),
		teamIDs,
		input.AssigneeIDs,
		input.DetectionIndicators,
	)
	if err != nil {
		errutil.Handle(ctx, err, "failed to create risk")
		return nil, err
	}

	return toGraphQLRisk(risk), nil
}

// UpdateRisk is the resolver for the updateRisk field.
func (r *mutationResolver) UpdateRisk(ctx context.Context, input graphql1.UpdateRiskInput) (*graphql1.Risk, error) {
	categoryIDs := make([]types.CategoryID, len(input.CategoryIDs))
	for i, id := range input.CategoryIDs {
		categoryIDs[i] = types.CategoryID(id)
	}

	teamIDs := make([]types.TeamID, len(input.ResponseTeamIDs))
	for i, id := range input.ResponseTeamIDs {
		teamIDs[i] = types.TeamID(id)
	}

	risk, err := r.uc.Risk.UpdateRisk(
		ctx,
		int64(input.ID),
		input.Name,
		input.Description,
		categoryIDs,
		input.SpecificImpact,
		types.LikelihoodID(input.LikelihoodID),
		types.ImpactID(input.ImpactID),
		teamIDs,
		input.AssigneeIDs,
		input.DetectionIndicators,
	)
	if err != nil {
		errutil.Handle(ctx, err, "failed to update risk")
		return nil, err
	}

	return toGraphQLRisk(risk), nil
}

// DeleteRisk is the resolver for the deleteRisk field.
func (r *mutationResolver) DeleteRisk(ctx context.Context, id int) (bool, error) {
	if err := r.uc.Risk.DeleteRisk(ctx, int64(id)); err != nil {
		errutil.Handle(ctx, err, "failed to delete risk")
		return false, err
	}

	return true, nil
}

// CreateResponse is the resolver for the createResponse field.
func (r *mutationResolver) CreateResponse(ctx context.Context, input graphql1.CreateResponseInput) (*graphql1.Response, error) {
	var status types.ResponseStatus
	if input.Status != nil {
		status = toDomainResponseStatus(*input.Status)
	} else {
		status = types.ResponseStatusBacklog
	}

	var riskIDs []int64
	if input.RiskIDs != nil {
		riskIDs = make([]int64, len(input.RiskIDs))
		for i, id := range input.RiskIDs {
			riskIDs[i] = int64(id)
		}
	}

	response, err := r.uc.Response.CreateResponse(
		ctx,
		input.Title,
		input.Description,
		input.ResponderIDs,
		stringPtrToString(input.URL),
		status,
		riskIDs,
	)
	if err != nil {
		errutil.Handle(ctx, err, "failed to create response")
		return nil, err
	}

	return toGraphQLResponse(response), nil
}

// UpdateResponse is the resolver for the updateResponse field.
func (r *mutationResolver) UpdateResponse(ctx context.Context, input graphql1.UpdateResponseInput) (*graphql1.Response, error) {
	var status *types.ResponseStatus
	if input.Status != nil {
		s := toDomainResponseStatus(*input.Status)
		status = &s
	}

	var riskIDs []int64
	if input.RiskIDs != nil {
		riskIDs = make([]int64, len(input.RiskIDs))
		for i, id := range input.RiskIDs {
			riskIDs[i] = int64(id)
		}
	}

	response, err := r.uc.Response.UpdateResponse(
		ctx,
		int64(input.ID),
		input.Title,
		input.Description,
		input.ResponderIDs,
		input.URL,
		status,
		riskIDs,
	)
	if err != nil {
		errutil.Handle(ctx, err, "failed to update response")
		return nil, err
	}

	return toGraphQLResponse(response), nil
}

// DeleteResponse is the resolver for the deleteResponse field.
func (r *mutationResolver) DeleteResponse(ctx context.Context, id int) (bool, error) {
	if err := r.uc.Response.DeleteResponse(ctx, int64(id)); err != nil {
		errutil.Handle(ctx, err, "failed to delete response")
		return false, err
	}

	return true, nil
}

// LinkResponseToRisk is the resolver for the linkResponseToRisk field.
func (r *mutationResolver) LinkResponseToRisk(ctx context.Context, responseID int, riskID int) (bool, error) {
	if err := r.uc.Response.LinkResponseToRisk(ctx, int64(responseID), int64(riskID)); err != nil {
		errutil.Handle(ctx, err, "failed to link response to risk")
		return false, err
	}

	return true, nil
}

// UnlinkResponseFromRisk is the resolver for the unlinkResponseFromRisk field.
func (r *mutationResolver) UnlinkResponseFromRisk(ctx context.Context, responseID int, riskID int) (bool, error) {
	if err := r.uc.Response.UnlinkResponseFromRisk(ctx, int64(responseID), int64(riskID)); err != nil {
		errutil.Handle(ctx, err, "failed to unlink response from risk")
		return false, err
	}

	return true, nil
}

// CreateNotionDBSource is the resolver for the createNotionDBSource field.
func (r *mutationResolver) CreateNotionDBSource(ctx context.Context, input graphql1.CreateNotionDBSourceInput) (*graphql1.Source, error) {
	ucInput := toUseCaseCreateNotionDBSourceInput(input)

	source, err := r.uc.Source.CreateNotionDBSource(ctx, ucInput)
	if err != nil {
		errutil.Handle(ctx, err, "failed to create Notion DB source")
		return nil, err
	}

	return toGraphQLSource(source)
}

// CreateSlackSource is the resolver for the createSlackSource field.
func (r *mutationResolver) CreateSlackSource(ctx context.Context, input graphql1.CreateSlackSourceInput) (*graphql1.Source, error) {
	ucInput := toUseCaseCreateSlackSourceInput(input)

	source, err := r.uc.Source.CreateSlackSource(ctx, ucInput)
	if err != nil {
		errutil.Handle(ctx, err, "failed to create Slack source")
		return nil, err
	}

	return toGraphQLSource(source)
}

// UpdateSource is the resolver for the updateSource field.
func (r *mutationResolver) UpdateSource(ctx context.Context, input graphql1.UpdateSourceInput) (*graphql1.Source, error) {
	ucInput := toUseCaseUpdateSourceInput(input)

	source, err := r.uc.Source.UpdateSource(ctx, ucInput)
	if err != nil {
		errutil.Handle(ctx, err, "failed to update source")
		return nil, err
	}

	return toGraphQLSource(source)
}

// UpdateSlackSource is the resolver for the updateSlackSource field.
func (r *mutationResolver) UpdateSlackSource(ctx context.Context, input graphql1.UpdateSlackSourceInput) (*graphql1.Source, error) {
	ucInput := toUseCaseUpdateSlackSourceInput(input)

	source, err := r.uc.Source.UpdateSlackSource(ctx, ucInput)
	if err != nil {
		errutil.Handle(ctx, err, "failed to update Slack source")
		return nil, err
	}

	return toGraphQLSource(source)
}

// DeleteSource is the resolver for the deleteSource field.
func (r *mutationResolver) DeleteSource(ctx context.Context, id string) (bool, error) {
	if err := r.uc.Source.DeleteSource(ctx, model.SourceID(id)); err != nil {
		errutil.Handle(ctx, err, "failed to delete source")
		return false, err
	}

	return true, nil
}

// ValidateNotionDb is the resolver for the validateNotionDB field.
func (r *mutationResolver) ValidateNotionDb(ctx context.Context, databaseID string) (*graphql1.NotionDBValidationResult, error) {
	result, err := r.uc.Source.ValidateNotionDB(ctx, databaseID)
	if err != nil {
		errutil.Handle(ctx, err, "failed to validate Notion DB")
		return nil, err
	}

	return &graphql1.NotionDBValidationResult{
		Valid:         result.Valid,
		DatabaseTitle: &result.DatabaseTitle,
		DatabaseURL:   &result.DatabaseURL,
		ErrorMessage:  &result.ErrorMessage,
	}, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	// TODO: Remove this dummy implementation when real health check is added
	return "OK", nil
}

// Risks is the resolver for the risks field.
func (r *queryResolver) Risks(ctx context.Context) ([]*graphql1.Risk, error) {
	risks, err := r.uc.Risk.ListRisks(ctx)
	if err != nil {
		errutil.Handle(ctx, err, "failed to list risks")
		return nil, err
	}

	gqlRisks := make([]*graphql1.Risk, len(risks))
	for i, risk := range risks {
		gqlRisks[i] = toGraphQLRisk(risk)
	}

	return gqlRisks, nil
}

// Risk is the resolver for the risk field.
func (r *queryResolver) Risk(ctx context.Context, id int) (*graphql1.Risk, error) {
	risk, err := r.uc.Risk.GetRisk(ctx, int64(id))
	if err != nil {
		errutil.Handle(ctx, err, "failed to get risk")
		return nil, err
	}

	return toGraphQLRisk(risk), nil
}

// RiskConfiguration is the resolver for the riskConfiguration field.
func (r *queryResolver) RiskConfiguration(ctx context.Context) (*graphql1.RiskConfiguration, error) {
	config, err := r.uc.Risk.GetRiskConfiguration()
	if err != nil {
		errutil.Handle(ctx, err, "failed to get risk configuration")
		return nil, err
	}

	categories := make([]*graphql1.Category, len(config.Categories))
	for i, cat := range config.Categories {
		categories[i] = &graphql1.Category{
			ID:          cat.ID,
			Name:        cat.Name,
			Description: cat.Description,
		}
	}

	likelihoodLevels := make([]*graphql1.LikelihoodLevel, len(config.Likelihood))
	for i, level := range config.Likelihood {
		likelihoodLevels[i] = &graphql1.LikelihoodLevel{
			ID:          level.ID,
			Name:        level.Name,
			Description: level.Description,
			Score:       level.Score,
		}
	}

	impactLevels := make([]*graphql1.ImpactLevel, len(config.Impact))
	for i, level := range config.Impact {
		impactLevels[i] = &graphql1.ImpactLevel{
			ID:          level.ID,
			Name:        level.Name,
			Description: level.Description,
			Score:       level.Score,
		}
	}

	teams := make([]*graphql1.Team, len(config.Teams))
	for i, team := range config.Teams {
		teams[i] = &graphql1.Team{
			ID:   team.ID,
			Name: team.Name,
		}
	}

	return &graphql1.RiskConfiguration{
		Categories:       categories,
		LikelihoodLevels: likelihoodLevels,
		ImpactLevels:     impactLevels,
		Teams:            teams,
	}, nil
}

// SlackUsers is the resolver for the slackUsers field.
func (r *queryResolver) SlackUsers(ctx context.Context) ([]*graphql1.SlackUser, error) {
	if r.uc.Auth == nil {
		return []*graphql1.SlackUser{}, nil
	}

	users, err := r.uc.Auth.GetSlackUsers(ctx)
	if err != nil {
		errutil.Handle(ctx, err, "failed to get Slack users")
		return nil, err
	}

	gqlUsers := make([]*graphql1.SlackUser, len(users))
	for i, user := range users {
		gqlUsers[i] = &graphql1.SlackUser{
			ID:       user.ID,
			Name:     user.Name,
			RealName: user.RealName,
			ImageURL: user.ImageURL,
		}
	}

	return gqlUsers, nil
}

// Responses is the resolver for the responses field.
func (r *queryResolver) Responses(ctx context.Context) ([]*graphql1.Response, error) {
	responses, err := r.uc.Response.ListResponses(ctx)
	if err != nil {
		errutil.Handle(ctx, err, "failed to list responses")
		return nil, err
	}

	gqlResponses := make([]*graphql1.Response, len(responses))
	for i, response := range responses {
		gqlResponses[i] = enrichResponse(ctx, r.uc, toGraphQLResponse(response))
	}

	return gqlResponses, nil
}

// Response is the resolver for the response field.
func (r *queryResolver) Response(ctx context.Context, id int) (*graphql1.Response, error) {
	response, err := r.uc.Response.GetResponse(ctx, int64(id))
	if err != nil {
		errutil.Handle(ctx, err, "failed to get response")
		return nil, err
	}

	return enrichResponse(ctx, r.uc, toGraphQLResponse(response)), nil
}

// ResponsesByRisk is the resolver for the responsesByRisk field.
func (r *queryResolver) ResponsesByRisk(ctx context.Context, riskID int) ([]*graphql1.Response, error) {
	responses, err := r.uc.Response.GetResponsesByRisk(ctx, int64(riskID))
	if err != nil {
		errutil.Handle(ctx, err, "failed to get responses by risk")
		return nil, err
	}

	gqlResponses := make([]*graphql1.Response, len(responses))
	for i, response := range responses {
		gqlResponses[i] = enrichResponse(ctx, r.uc, toGraphQLResponse(response))
	}

	return gqlResponses, nil
}

// Sources is the resolver for the sources field.
func (r *queryResolver) Sources(ctx context.Context) ([]*graphql1.Source, error) {
	sources, err := r.uc.Source.ListSources(ctx)
	if err != nil {
		errutil.Handle(ctx, err, "failed to list sources")
		return nil, err
	}

	gqlSources := make([]*graphql1.Source, len(sources))
	for i, source := range sources {
		gqlSource, err := toGraphQLSource(source)
		if err != nil {
			return nil, err
		}
		gqlSources[i] = gqlSource
	}

	return gqlSources, nil
}

// Source is the resolver for the source field.
func (r *queryResolver) Source(ctx context.Context, id string) (*graphql1.Source, error) {
	source, err := r.uc.Source.GetSource(ctx, model.SourceID(id))
	if err != nil {
		errutil.Handle(ctx, err, "failed to get source")
		return nil, err
	}

	return toGraphQLSource(source)
}

// SlackJoinedChannels is the resolver for the slackJoinedChannels field.
func (r *queryResolver) SlackJoinedChannels(ctx context.Context) ([]*graphql1.SlackChannelInfo, error) {
	channels, err := r.uc.Source.ListSlackChannels(ctx)
	if err != nil {
		errutil.Handle(ctx, err, "failed to list Slack channels")
		return nil, err
	}

	gqlChannels := make([]*graphql1.SlackChannelInfo, len(channels))
	for i, ch := range channels {
		gqlChannels[i] = &graphql1.SlackChannelInfo{
			ID:   ch.ID,
			Name: ch.Name,
		}
	}

	return gqlChannels, nil
}

// Responses is the resolver for the responses field on Risk.
func (r *riskResolver) Responses(ctx context.Context, obj *graphql1.Risk) ([]*graphql1.Response, error) {
	loaders := GetDataLoaders(ctx)
	if loaders == nil || loaders.ResponsesByRiskLoader == nil {
		// Fallback to direct query if DataLoader is not available
		responses, err := r.uc.Response.GetResponsesByRisk(ctx, int64(obj.ID))
		if err != nil {
			errutil.Handle(ctx, err, "failed to get responses by risk")
			return nil, err
		}

		gqlResponses := make([]*graphql1.Response, len(responses))
		for i, response := range responses {
			gqlResponses[i] = enrichResponse(ctx, r.uc, toGraphQLResponse(response))
		}
		return gqlResponses, nil
	}

	responses, err := loaders.ResponsesByRiskLoader.Load(ctx, int64(obj.ID))
	if err != nil {
		errutil.Handle(ctx, err, "failed to load responses by risk")
		return nil, err
	}

	gqlResponses := make([]*graphql1.Response, len(responses))
	for i, response := range responses {
		gqlResponses[i] = enrichResponse(ctx, r.uc, toGraphQLResponse(response))
	}

	return gqlResponses, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Risk returns RiskResolver implementation.
func (r *Resolver) Risk() RiskResolver { return &riskResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type riskResolver struct{ *Resolver }
