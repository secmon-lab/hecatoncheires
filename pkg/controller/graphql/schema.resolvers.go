package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"encoding/json"

	"github.com/secmon-lab/hecatoncheires/pkg/domain/model"
	graphql1 "github.com/secmon-lab/hecatoncheires/pkg/domain/model/graphql"
	"github.com/secmon-lab/hecatoncheires/pkg/domain/types"
)

// Case is the resolver for the case field.
func (r *actionResolver) Case(ctx context.Context, obj *graphql1.Action) (*graphql1.Case, error) {
	loaders := GetDataLoaders(ctx)
	cases, err := loaders.CaseLoader.Load(ctx, []int64{int64(obj.CaseID)})
	if err != nil {
		return nil, err
	}
	if len(cases) == 0 {
		return nil, nil
	}
	return toGraphQLCase(cases[0]), nil
}

// Assignees is the resolver for the assignees field.
func (r *actionResolver) Assignees(ctx context.Context, obj *graphql1.Action) ([]*graphql1.SlackUser, error) {
	if len(obj.AssigneeIDs) == 0 {
		return []*graphql1.SlackUser{}, nil
	}
	loaders := GetDataLoaders(ctx)
	return loaders.SlackUserLoader.Load(ctx, obj.AssigneeIDs)
}

// Assignees is the resolver for the assignees field.
func (r *caseResolver) Assignees(ctx context.Context, obj *graphql1.Case) ([]*graphql1.SlackUser, error) {
	if len(obj.AssigneeIDs) == 0 {
		return []*graphql1.SlackUser{}, nil
	}
	loaders := GetDataLoaders(ctx)
	return loaders.SlackUserLoader.Load(ctx, obj.AssigneeIDs)
}

// Fields is the resolver for the fields field.
func (r *caseResolver) Fields(ctx context.Context, obj *graphql1.Case) ([]*graphql1.FieldValue, error) {
	loaders := GetDataLoaders(ctx)
	fieldsMap, err := loaders.CaseFieldValueLoader.Load(ctx, []int64{int64(obj.ID)})
	if err != nil {
		return nil, err
	}
	fields, ok := fieldsMap[int64(obj.ID)]
	if !ok {
		return []*graphql1.FieldValue{}, nil
	}

	// Convert domain FieldValue to GraphQL FieldValue
	result := make([]*graphql1.FieldValue, len(fields))
	for i, f := range fields {
		result[i] = toGraphQLFieldValue(&f)
	}
	return result, nil
}

// Actions is the resolver for the actions field.
func (r *caseResolver) Actions(ctx context.Context, obj *graphql1.Case) ([]*graphql1.Action, error) {
	loaders := GetDataLoaders(ctx)
	actionsMap, err := loaders.ActionsByCaseLoader.Load(ctx, []int64{int64(obj.ID)})
	if err != nil {
		return nil, err
	}
	actions, ok := actionsMap[int64(obj.ID)]
	if !ok {
		return []*graphql1.Action{}, nil
	}

	// Convert domain Actions to GraphQL Actions
	result := make([]*graphql1.Action, len(actions))
	for i, a := range actions {
		result[i] = toGraphQLAction(a)
	}
	return result, nil
}

// Knowledges is the resolver for the knowledges field.
func (r *caseResolver) Knowledges(ctx context.Context, obj *graphql1.Case) ([]*graphql1.Knowledge, error) {
	loaders := GetDataLoaders(ctx)
	knowledgesMap, err := loaders.KnowledgesByCaseLoader.Load(ctx, []int64{int64(obj.ID)})
	if err != nil {
		return nil, err
	}
	knowledges, ok := knowledgesMap[int64(obj.ID)]
	if !ok {
		return []*graphql1.Knowledge{}, nil
	}

	// Convert domain Knowledge to GraphQL Knowledge
	result := make([]*graphql1.Knowledge, len(knowledges))
	for i, k := range knowledges {
		result[i] = toGraphQLKnowledge(k)
	}
	return result, nil
}

// Case is the resolver for the case field.
func (r *knowledgeResolver) Case(ctx context.Context, obj *graphql1.Knowledge) (*graphql1.Case, error) {
	loaders := GetDataLoaders(ctx)
	cases, err := loaders.CaseLoader.Load(ctx, []int64{int64(obj.CaseID)})
	if err != nil {
		return nil, err
	}
	if len(cases) == 0 {
		return nil, nil
	}
	return toGraphQLCase(cases[0]), nil
}

// Noop is the resolver for the noop field.
func (r *mutationResolver) Noop(ctx context.Context) (*bool, error) {
	result := true
	return &result, nil
}

// CreateCase is the resolver for the createCase field.
func (r *mutationResolver) CreateCase(ctx context.Context, input graphql1.CreateCaseInput) (*graphql1.Case, error) {
	assigneeIDs := input.AssigneeIDs
	if assigneeIDs == nil {
		assigneeIDs = []string{}
	}

	fields := make([]model.FieldValue, 0)
	if input.Fields != nil {
		for _, f := range input.Fields {
			fields = append(fields, toDomainFieldValue(*f))
		}
	}

	created, err := r.UseCases.Case.CreateCase(ctx, input.Title, input.Description, assigneeIDs, fields)
	if err != nil {
		return nil, err
	}

	return toGraphQLCase(created), nil
}

// UpdateCase is the resolver for the updateCase field.
func (r *mutationResolver) UpdateCase(ctx context.Context, input graphql1.UpdateCaseInput) (*graphql1.Case, error) {
	assigneeIDs := input.AssigneeIDs
	if assigneeIDs == nil {
		assigneeIDs = []string{}
	}

	fields := make([]model.FieldValue, 0)
	if input.Fields != nil {
		for _, f := range input.Fields {
			fields = append(fields, toDomainFieldValue(*f))
		}
	}

	updated, err := r.UseCases.Case.UpdateCase(ctx, int64(input.ID), input.Title, input.Description, assigneeIDs, fields)
	if err != nil {
		return nil, err
	}

	return toGraphQLCase(updated), nil
}

// DeleteCase is the resolver for the deleteCase field.
func (r *mutationResolver) DeleteCase(ctx context.Context, id int) (bool, error) {
	if err := r.UseCases.Case.DeleteCase(ctx, int64(id)); err != nil {
		return false, err
	}
	return true, nil
}

// CreateAction is the resolver for the createAction field.
func (r *mutationResolver) CreateAction(ctx context.Context, input graphql1.CreateActionInput) (*graphql1.Action, error) {
	assigneeIDs := input.AssigneeIDs
	if assigneeIDs == nil {
		assigneeIDs = []string{}
	}

	slackMessageTS := ""
	if input.SlackMessageTs != nil {
		slackMessageTS = *input.SlackMessageTs
	}

	status := types.ActionStatusTodo
	if input.Status != nil {
		status = *input.Status
	}

	created, err := r.UseCases.Action.CreateAction(ctx, int64(input.CaseID), input.Title, input.Description, assigneeIDs, slackMessageTS, status)
	if err != nil {
		return nil, err
	}

	return toGraphQLAction(created), nil
}

// UpdateAction is the resolver for the updateAction field.
func (r *mutationResolver) UpdateAction(ctx context.Context, input graphql1.UpdateActionInput) (*graphql1.Action, error) {
	var caseID *int64
	if input.CaseID != nil {
		id := int64(*input.CaseID)
		caseID = &id
	}

	var slackMessageTS *string
	if input.SlackMessageTs != nil {
		slackMessageTS = input.SlackMessageTs
	}

	var status *types.ActionStatus
	if input.Status != nil {
		status = input.Status
	}

	updated, err := r.UseCases.Action.UpdateAction(ctx, int64(input.ID), caseID, input.Title, input.Description, input.AssigneeIDs, slackMessageTS, status)
	if err != nil {
		return nil, err
	}

	return toGraphQLAction(updated), nil
}

// DeleteAction is the resolver for the deleteAction field.
func (r *mutationResolver) DeleteAction(ctx context.Context, id int) (bool, error) {
	if err := r.UseCases.Action.DeleteAction(ctx, int64(id)); err != nil {
		return false, err
	}
	return true, nil
}

// CreateNotionDBSource is the resolver for the createNotionDBSource field.
func (r *mutationResolver) CreateNotionDBSource(ctx context.Context, input graphql1.CreateNotionDBSourceInput) (*graphql1.Source, error) {
	created, err := r.UseCases.Source.CreateNotionDBSource(ctx, toUseCaseCreateNotionDBSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(created)
}

// CreateSlackSource is the resolver for the createSlackSource field.
func (r *mutationResolver) CreateSlackSource(ctx context.Context, input graphql1.CreateSlackSourceInput) (*graphql1.Source, error) {
	created, err := r.UseCases.Source.CreateSlackSource(ctx, toUseCaseCreateSlackSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(created)
}

// UpdateSource is the resolver for the updateSource field.
func (r *mutationResolver) UpdateSource(ctx context.Context, input graphql1.UpdateSourceInput) (*graphql1.Source, error) {
	updated, err := r.UseCases.Source.UpdateSource(ctx, toUseCaseUpdateSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(updated)
}

// UpdateSlackSource is the resolver for the updateSlackSource field.
func (r *mutationResolver) UpdateSlackSource(ctx context.Context, input graphql1.UpdateSlackSourceInput) (*graphql1.Source, error) {
	updated, err := r.UseCases.Source.UpdateSlackSource(ctx, toUseCaseUpdateSlackSourceInput(input))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(updated)
}

// DeleteSource is the resolver for the deleteSource field.
func (r *mutationResolver) DeleteSource(ctx context.Context, id string) (bool, error) {
	if err := r.UseCases.Source.DeleteSource(ctx, model.SourceID(id)); err != nil {
		return false, err
	}
	return true, nil
}

// ValidateNotionDb is the resolver for the validateNotionDB field.
func (r *mutationResolver) ValidateNotionDb(ctx context.Context, databaseID string) (*graphql1.NotionDBValidationResult, error) {
	result, err := r.UseCases.Source.ValidateNotionDB(ctx, databaseID)
	if err != nil {
		return nil, err
	}

	gql := &graphql1.NotionDBValidationResult{
		Valid: result.Valid,
	}
	if result.DatabaseTitle != "" {
		gql.DatabaseTitle = &result.DatabaseTitle
	}
	if result.DatabaseURL != "" {
		gql.DatabaseURL = &result.DatabaseURL
	}
	if result.ErrorMessage != "" {
		gql.ErrorMessage = &result.ErrorMessage
	}

	return gql, nil
}

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "ok", nil
}

// Cases is the resolver for the cases field.
func (r *queryResolver) Cases(ctx context.Context) ([]*graphql1.Case, error) {
	cases, err := r.UseCases.Case.ListCases(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Case, len(cases))
	for i, c := range cases {
		result[i] = toGraphQLCase(c)
	}

	return result, nil
}

// Case is the resolver for the case field.
func (r *queryResolver) Case(ctx context.Context, id int) (*graphql1.Case, error) {
	c, err := r.UseCases.Case.GetCase(ctx, int64(id))
	if err != nil {
		return nil, err
	}

	return toGraphQLCase(c), nil
}

// Actions is the resolver for the actions field.
func (r *queryResolver) Actions(ctx context.Context) ([]*graphql1.Action, error) {
	actions, err := r.UseCases.Action.ListActions(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Action, len(actions))
	for i, a := range actions {
		result[i] = toGraphQLAction(a)
	}

	return result, nil
}

// Action is the resolver for the action field.
func (r *queryResolver) Action(ctx context.Context, id int) (*graphql1.Action, error) {
	a, err := r.UseCases.Action.GetAction(ctx, int64(id))
	if err != nil {
		return nil, err
	}

	return toGraphQLAction(a), nil
}

// ActionsByCase is the resolver for the actionsByCase field.
func (r *queryResolver) ActionsByCase(ctx context.Context, caseID int) ([]*graphql1.Action, error) {
	actions, err := r.UseCases.Action.GetActionsByCase(ctx, int64(caseID))
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Action, len(actions))
	for i, a := range actions {
		result[i] = toGraphQLAction(a)
	}

	return result, nil
}

// FieldConfiguration is the resolver for the fieldConfiguration field.
func (r *queryResolver) FieldConfiguration(ctx context.Context) (*graphql1.FieldConfiguration, error) {
	schema := r.UseCases.Case.GetFieldConfiguration()

	fields := make([]*graphql1.FieldDefinition, len(schema.Fields))
	for i, field := range schema.Fields {
		options := make([]*graphql1.FieldOption, len(field.Options))
		for j, opt := range field.Options {
			color := ""
			if opt.Color != "" {
				color = opt.Color
			}
			metadata := opt.Metadata
			if metadata == nil {
				metadata = make(map[string]any)
			}
			metadataJSON, _ := json.Marshal(metadata)
			metadataStr := string(metadataJSON)

			options[j] = &graphql1.FieldOption{
				ID:          opt.ID,
				Name:        opt.Name,
				Description: &opt.Description,
				Color:       &color,
				Metadata:    &metadataStr,
			}
		}

		fieldType := toGraphQLFieldType(field.Type)

		fields[i] = &graphql1.FieldDefinition{
			ID:          field.ID,
			Name:        field.Name,
			Type:        fieldType,
			Required:    field.Required,
			Description: &field.Description,
			Options:     options,
		}
	}

	return &graphql1.FieldConfiguration{
		Fields: fields,
		Labels: &graphql1.EntityLabels{
			Case: schema.Labels.Case,
		},
	}, nil
}

// SlackUsers is the resolver for the slackUsers field.
func (r *queryResolver) SlackUsers(ctx context.Context) ([]*graphql1.SlackUser, error) {
	users, err := r.repo.SlackUser().GetAll(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.SlackUser, len(users))
	for i, u := range users {
		var imageURL *string
		if u.ImageURL != "" {
			url := u.ImageURL
			imageURL = &url
		}
		result[i] = &graphql1.SlackUser{
			ID:       string(u.ID),
			Name:     u.Name,
			RealName: u.RealName,
			ImageURL: imageURL,
		}
	}

	return result, nil
}

// SlackJoinedChannels is the resolver for the slackJoinedChannels field.
func (r *queryResolver) SlackJoinedChannels(ctx context.Context) ([]*graphql1.SlackChannelInfo, error) {
	channels, err := r.UseCases.Source.ListSlackChannels(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.SlackChannelInfo, len(channels))
	for i, ch := range channels {
		result[i] = &graphql1.SlackChannelInfo{
			ID:   ch.ID,
			Name: ch.Name,
		}
	}

	return result, nil
}

// Sources is the resolver for the sources field.
func (r *queryResolver) Sources(ctx context.Context) ([]*graphql1.Source, error) {
	sources, err := r.UseCases.Source.ListSources(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]*graphql1.Source, 0, len(sources))
	for _, s := range sources {
		gql, err := toGraphQLSource(s)
		if err != nil {
			return nil, err
		}
		result = append(result, gql)
	}

	return result, nil
}

// Source is the resolver for the source field.
func (r *queryResolver) Source(ctx context.Context, id string) (*graphql1.Source, error) {
	source, err := r.UseCases.Source.GetSource(ctx, model.SourceID(id))
	if err != nil {
		return nil, err
	}

	return toGraphQLSource(source)
}

// Knowledge is the resolver for the knowledge field.
func (r *queryResolver) Knowledge(ctx context.Context, id string) (*graphql1.Knowledge, error) {
	knowledge, err := r.repo.Knowledge().Get(ctx, model.KnowledgeID(id))
	if err != nil {
		return nil, err
	}

	return toGraphQLKnowledge(knowledge), nil
}

// Knowledges is the resolver for the knowledges field.
func (r *queryResolver) Knowledges(ctx context.Context, limit *int, offset *int) (*graphql1.KnowledgeConnection, error) {
	// Set defaults if not provided
	limitVal := 100
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}

	offsetVal := 0
	if offset != nil && *offset > 0 {
		offsetVal = *offset
	}

	knowledges, totalCount, err := r.repo.Knowledge().ListWithPagination(ctx, limitVal, offsetVal)
	if err != nil {
		return nil, err
	}

	// Convert domain Knowledge to GraphQL Knowledge
	items := make([]*graphql1.Knowledge, len(knowledges))
	for i, k := range knowledges {
		items[i] = toGraphQLKnowledge(k)
	}

	hasMore := (offsetVal + len(knowledges)) < totalCount

	return &graphql1.KnowledgeConnection{
		Items:      items,
		TotalCount: totalCount,
		HasMore:    hasMore,
	}, nil
}

// Action returns ActionResolver implementation.
func (r *Resolver) Action() ActionResolver { return &actionResolver{r} }

// Case returns CaseResolver implementation.
func (r *Resolver) Case() CaseResolver { return &caseResolver{r} }

// Knowledge returns KnowledgeResolver implementation.
func (r *Resolver) Knowledge() KnowledgeResolver { return &knowledgeResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type actionResolver struct{ *Resolver }
type caseResolver struct{ *Resolver }
type knowledgeResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
